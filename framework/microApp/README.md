## MicroAPP

## 微前端

微前端是一个架构体系，用于实现大型的web应用，并不是万能的架构体系，也不存在万能的架构。微前端最大的特色就是独立部署、独立发布、热升级，应用沙箱隔离，多团队协作等。

#### 优点

* 多人协作

* 系统解耦，独立开发部署

* 沙箱隔离，无关技术栈

* 增量升级

#### 缺点

1、应用切换资源重新加载，性能体验变差
2、应用拆分维护成本相应增加
3、版本管理、组件复用、依赖关系的清晰度等
4、沟通成本加大

#### 原理

实现方式有很多种，比如：iframe嵌套、将子应用打包成npm依赖包、子路由动态加载子应用资源

* 什么时候加载子应用？

  每个子应用分配一个基准路由 - /baseRoute，跳到对应基准路由加载对应子应用资源

* 如何捕捉基准路由变化？

  劫持 history.pushState 和 history.replaceState 两个 API，同时监听 popstate 事件，保证能够捕获到到所有路由变化。当捕获到路由变化时，根据路由查找对应的子应用，如果是新子应用则卸载当前子应用，同时加载新子应用并渲染。

* 如何将子应用的 bundle 渲染到指定节点？

  基座框架提给API 保证子应用能够渲染到指定的节点

* 刷新页面如何加载子应用？

  子应用资源都是懒加载的，重刷页面底座资源加载，同时底座的路由激活，但子应用的资源还没有完成加载，这时可能导致404或路由报错。因此，需要劫持 url change 事件实现自己的路由系统，预先加载子应用的资源，然后接管路由系统，退出此子应用，也可以用调用自己的方法卸载子应用。
  `destroy = () => ReactDOM.unmountAtNode(container)`


### 父子应用代码如何组合？

* 构建时

  通过 npm package 或者 git tags方式，优点是打包可以优化，缺点是主子应用耦合性强

* 运行时

  动态加载子应用的资源，优势主子应用完全解耦，缺点是运行维护难度加大

### 沙箱隔离

* iframe

* 约定规范：不要污染全局变量、定时器及时清除、CSS 样式尽量通过前缀或者 CSS Modules 做隔离

* Shadow DOM 和 Web Worker


### 流行框架

* single-spa 知名度高，生态完善，对子应用有一点侵入性

* qiankun 基于上者的封装

* icestark 轻量简单，API简单直观
